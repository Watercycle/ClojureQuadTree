<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1425190049529">{:repl-history {:ide [], :local [&quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [200 200 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (vals indexed-objs) 6)\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(group-by #(qt/get-index test-region %) test-objs)&quot; &quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [200 200 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (vals indexed-objs)) 6\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [200 200 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (flatten (vals indexed-objs))) 6\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [200 200 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (apply concat (vals indexed-objs))) 6\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [200 200 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (mapcat concat (vals indexed-objs))) 6\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(vals (group-by #(qt/get-index test-region %) test-objs))&quot; &quot;(type (mapcat concat (vals (group-by #(qt/get-index test-region %) test-objs))))&quot; &quot;(mapcat concat (vals (group-by #(qt/get-index test-region %) test-objs)))&quot; &quot;(:I (group-by #(qt/get-index test-region %) test-objs))&quot; &quot;(type (flatten (:I (group-by #(qt/get-index test-region %) test-objs))))&quot; &quot;(flatten (:I (group-by #(qt/get-index test-region %) test-objs)))&quot; &quot;(defn build-quadtree [region objs]\n  (let [base-region region\n        indexed-objs (group-by #(get-index region %) objs)\n        base-objs (flatten (:NONE indexed-objs))\n        nodes (insert-all region (dissoc indexed-objs :NONE))]\n    (quad. 0 base-region base-objs nodes)))&quot; &quot;(defn draw []\n  (q/background 0)\n  (q/text (str \&quot;max depth: \&quot; 5) 250 22)\n;  (q/text (str \&quot;active nodes: \&quot; qt/num-nodes) 200 46)\n  (q/text (str \&quot;total objects: \&quot; num-obj) 250 70)\n  (q/text (str \&quot;obj 0 x pos: \&quot; (nth (first @objs) 1)) 250 94))&quot; &quot;(defn insert-all [region objs lvl]\n  (let [div (split region)]\n    [(quad. (inc lvl) [I])]))&quot; &quot;(defn split [x y w h]\n  (let [hw (/ w 2) hh (/ h 2)\n        cx (+ x hw) cy (+ y hh)]\n    {:I   [cx y hw hh]\n     :II  [x y hw hh]\n     :III [x cy hw hh]\n     :IV  [cx cy hw hh]}))&quot; &quot;(defn make-quad [region lvl objs]\n  (let [indexed-objs (index region objs)\n        base-objs (flatten (:NONE indexed-objs))\n        nodes (insert-all region (dissoc indexed-objs :NONE) lvl)]\n    (quad. lvl region base-objs nodes)))&quot; &quot;(defn insert-all [region objs level]\n  (let [div (split region)\n        lvl (inc level)\n        quadrants [:I :II :III :IV]]\n     (map (make-quad (% div) lvl (% objs)) quadrants)))&quot; &quot;(map [% %] options)&quot; &quot;(map [%] options)&quot; &quot;(map options)&quot; &quot;(map = options)&quot; &quot;(map + options)&quot; &quot;(map (+) options)&quot; &quot;(map (+ 1 %) options)&quot; &quot;(defn options [1 2 3 4 5 6])&quot; &quot;(map #(+ 1 %) options)&quot; &quot;(map +1 options)&quot; &quot;(map  + options)&quot; &quot;(map #(+ % 1) options)&quot; &quot;(apply #(+ % 1) options)&quot; &quot;(apply #(+ % 1) '(1 2 3))&quot; &quot;(defn insert-all [region objs level]\n  (let [div (split region)\n        lvl (inc level)\n        quadrants [:I :II :III :IV]]\n     (map #(make-quad (%1 div) lvl (%2 objs)) quadrants quadrants)))&quot; &quot;(mao #(+ % 1) options)&quot; &quot;(mao #(+ % 1) [1 2 3 4 5 6])&quot; &quot;(map #(+ % 1) [1 2 3 4 5 6])&quot; &quot;(map (println %) [1 2 3 4 5 6])&quot; &quot;(map (do #(println %)) [1 2 3 4 5 6])&quot; &quot;(map #((do println) %) [1 2 3 4 5 6])&quot; &quot;(map #((do println %)) [1 2 3 4 5 6])&quot; &quot;(map #((println %) %) [1 2 3 4 5 6])&quot; &quot;(map #((println %)) [1 2 3 4 5 6])&quot; &quot;(map #((println %) 1) [1 2 3 4 5 6])&quot; &quot;(map #(println %) [1 2 3 4 5 6])&quot; &quot;(map #(println (% + %)) [1 2 3 4 5 6])&quot; &quot;(map #(println (+ % %)) [1 2 3 4 5 6])&quot; &quot;(defn insert-all [region objs level]\n  (let [div (split region)\n        lvl (inc level)\n        quadrants [:I :II :III :IV]]\n     (map #(make-quad (% div) lvl (% objs)) quadrants)))&quot; &quot;(defn setup []\n  (q/smooth)                                                ;antialiasing\n  (q/frame-rate 60)\n\n  (q/stroke-weight 3)\n  (q/stroke 0 0 125)\n\n  (let [x (q/random (q/width))]\n    (q/line x 0 x (q/height)))\n\n  (q/text-align :right)\n  (q/fill 255)\n  (q/text-size 25)\n\n  (qt/build-quadtree [0 0 300 300] @objs)\n  )&quot; &quot;(qt/build-quadtree [0 0 300 300] @objs)&quot; &quot;(qt/build-quadtree test-region test-objs 1)&quot; &quot;(defn others [:a :b])&quot; &quot;(map #(:a objects) others)&quot; &quot;(ns quadtree.core-test\n  (:use [cloj/ure.test] :reload)\n  (:import [quadtree.tree rect])\n  (:require [quadtree.core :refer :all]\n            [quadtree.tree :as qt]))&quot; &quot;(ns quadtree.core-test\n  (:use [clojure.test] :reload)\n  (:import [quadtree.tree rect])\n  (:require [quadtree.core :refer :all]\n            [quadtree.tree :as qt]))&quot; &quot;(defn build-quadtree\n  ([region objs lvl]\n   (let [indexed-objs (index region objs)\n         base-objs (flatten (:NONE indexed-objs))\n         nodes (insert-all region (dissoc indexed-objs :NONE) lvl)]\n     (quad. lvl region base-objs nodes)))\n  ([region objs] (build-quadtree region objs 0)))&quot; &quot;(defn insert-all [region objs level]\n  (let [div (split region)\n        lvl (inc level)\n        quadrants [:I :II :III :IV]]\n    (if (empty? objs)\n      (map #(build-quadtree (% div) (% objs) lvl) quadrants)\n      nil)))&quot; &quot;(defn insert-all [region objs level]\n  (if (&lt; (count objs) max-obj)\n    (let [div (split region)\n          lvl (inc level)\n          quadrants [:I :II :III :IV]]\n      (if (not-empty objs)\n        (map #(build-quadtree (% div) (% objs) lvl) quadrants)\n        nil))\n    nil))&quot; &quot;(defn insert-all [region objs level]\n  (if (and (not-empty objs) (&lt; (count objs) max-obj))\n    (let [div (split region)\n          lvl (inc level)\n          quadrants [:I :II :III :IV]]\n      (map #(build-quadtree (% div) (% objs) lvl) quadrants)\n      nil)\n    nil))&quot; &quot;(defn insert-all [region objs level]\n  (if (empty objs) nil\n                   (let [div (split region)\n                         lvl (inc level)\n                         quadrants [:I :II :III :IV]]\n                     (map #(build-quadtree (% div) (% objs) lvl) quadrants))))&quot; &quot;(defn insert-all [region objs level]\n  (if (not-empty objs)\n    (let [div (split region)\n          lvl (inc level)\n          quadrants [:I :II :III :IV]]\n      (map #(build-quadtree (% div) (% objs) lvl) quadrants))\n    nil))&quot; &quot;(if (not-empty '( 1 2 3)) 1 2)&quot; &quot;(if (not-empty '()) 1 2)&quot; &quot;(def max-obj 4)&quot; &quot;(defn insert-all [region objs level]\n;  (if (not-empty objs))\n  (let [div (split region)\n        lvl (inc level)\n        quadrants [:I :II :III :IV]]\n    (map #(build-quadtree (% div) (% objs) lvl) quadrants)))&quot; &quot;(qt/build-quadtree test-region test-objs)&quot; &quot;(*print-pretty* true)&quot; &quot;(clojure.pprint/print-table (qt/build-quadtree test-region test-objs))&quot; &quot;(clojure.pprint/pp (qt/build-quadtree test-region test-objs))&quot; &quot;(clojure.pprint/pprint-map (qt/build-quadtree test-region test-objs))&quot; &quot;(clojure.pprint/pprint (qt/build-quadtree test-region test-objs))&quot; &quot;(binding [*clojure.pprint/*print-right-margin* 7] (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 7] (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 50] (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 100] (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 200] (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(def max-obj 2)&quot; &quot;(binding\n  [clojure.pprint/*print-right-margin* 200]\n  [clojure.pprint/*print-pretty* true]\n  (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding\n  [clojure.pprint/*print-right-margin* 200]\n  [clojure.pprint/*print-pretty* false]\n  (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(binding \n  [clojure.pprint/*print-right-margin* 200] \n  [clojure.pprint/*print-pretty* true]\n  (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(deftest quad-build\n  (let [base-objs [[60 60 5 5] [70 70 5 5]\n                   [20 20 5 5] [130 175 5 5]\n                   [176 130 5 5] [173 400 5 5]]\n        base-region [50 50 250 250]\n        indexed-objs (group-by #(qt/get-index base-region %) base-objs)]\n    (are [a b] (= a b)\n               1 1\n               (count indexed-objs) 5\n               (count (mapcat concat (vals indexed-objs))) 6\n               (count (:II indexed-objs)) 2\n               )))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 200]\n  (clojure.pprint/pprint (qt/build-quadtree test-region test-objs)))&quot; &quot;(def others [:a :b])&quot; &quot;(def objects {:a [1 2 3] :b [2 3 4]})&quot; &quot;(map #(% objects) others)&quot; &quot;(map #(others (% objects)) others)&quot; &quot;(map #(% (% objects)) others)&quot; &quot;(map #((keyword %) (% objects)) others)&quot; &quot;(binding [clojure.pprint/*print-right-margin* 200]\n  (clojure.pprint/pprint (qt/build-quadtree [235 115 250 250] (rand-dots))))&quot; &quot;(ns quadtree.core\n  (:import [quadtree.tree rect])\n  (:require [quil.core :as q]\n            [quadtree.tree :as qt]))&quot; &quot;(qt/build-quadtree [235 115 250 250] rand-dots)&quot; &quot;(defn build-quadtree\n  ([region objs lvl zone]\n   (cond (&gt; (count objs) max-obj)\n         (let [indexed-objs (group-zones region objs)\n               base-objs (flatten (:NONE indexed-objs))\n               nodes (insert-all region (dissoc indexed-objs :NONE) lvl)]\n           {zone (quad. lvl region base-objs nodes)})\n         (&gt; (count objs) 0) {zone (quad. lvl region objs nil)}\n         :else nil)\n   (let [[x y w h] region]\n     (q/line (+ x (/ w 2)) y (+ x (/ w 2)) (+ y h))\n     (q/line x (+ y (/ h 2)) (+ x w) (+ y (/ h 2)))))\n  ([region objs] (build-quadtree region objs 0 :ROOT)))&quot; &quot;(defn setup []\n  (q/smooth)                                                ;antialiasing\n  (q/frame-rate 60)\n\n  (q/background 0)\n  (q/stroke-weight 3)\n  (q/stroke 0 0 125)\n\n  (q/text-align :right)\n  (q/fill 255)\n  (q/text-size 25)\n\n\n  (binding [clojure.pprint/*print-right-margin* 200]\n    (clojure.pprint/pprint (qt/build-quadtree [235 115 250 250] rand-dots)))\n  )&quot; &quot;(def objs (atom rand-dots))&quot; &quot;(def rand-dots\n  (repeat num-obj [(rand-int 300) (rand-int 300) 5 5]))&quot; &quot;(rand-dots)&quot; &quot;(defn build-quadtree\n  ([region objs lvl zone]\n   (cond (&gt; (count objs) max-obj)\n         (let [indexed-objs (group-zones region objs)\n               base-objs (flatten (:NONE indexed-objs))\n               nodes (insert-all region (dissoc indexed-objs :NONE) lvl)]\n           {zone (quad. lvl region base-objs nodes)})\n         (&gt; (count objs) 0) {zone (quad. lvl region objs nil)}\n         :else nil)\n   (let [[x y w h] region]\n;     (q/line (+ x (/ w 2)) y (+ x (/ w 2)) (+ y h))\n;     (q/line x (+ y (/ h 2)) (+ x w) (+ y (/ h 2)))\n     ))\n  ([region objs] (build-quadtree region objs 0 :ROOT)))&quot; &quot;rand-dots&quot; &quot;(defn build-quadtree\n  ([region objs lvl zone]\n   (cond (&gt; (count objs) max-obj)\n         (let [indexed-objs (group-zones region objs)\n               base-objs (flatten (:NONE indexed-objs))\n               nodes (insert-all region (dissoc indexed-objs :NONE) lvl)]\n           {zone (quad. lvl region base-objs nodes)})\n         (&gt; (count objs) 0) {zone (quad. lvl region objs nil)}\n         :else nil))\n  ([region objs] (build-quadtree region objs 0 :ROOT)))&quot; &quot;(let [[x y w h] region]\n  ;     (q/line (+ x (/ w 2)) y (+ x (/ w 2)) (+ y h))\n  ;     (q/line x (+ y (/ h 2)) (+ x w) (+ y (/ h 2)))\n  )&quot; &quot;(comment\n  (let [[x y w h] region]\n    ;     (q/line (+ x (/ w 2)) y (+ x (/ w 2)) (+ y h))\n    ;     (q/line x (+ y (/ h 2)) (+ x w) (+ y (/ h 2)))\n    ))&quot; &quot;(binding [clojure.pprint/*print-right-margin* 200]\n  (clojure.pprint/pprint (qt/build-quadtree [235 115 250 250] rand-dots)))&quot;], :remote []}}</component>
</project>